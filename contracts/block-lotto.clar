(define-constant ERR-REFUNDS-NOT-ALLOWED u112)
(define-constant ERR-NOT-ADMIN u113)
(define-constant ERR-PAUSED u114)
(define-data-var creator (optional principal) none)

;; Pause flag: when true, new entries and drawing are disabled (admin can pause)
(define-data-var paused bool false)
;; BlockLotto - A decentralized lottery system for Stacks (Clarity)
;; Author: Generated by GitHub Copilot (GPT-5 mini)
;; Notes:
;; - Entry fee is fixed (in micro-STX). 1 STX = 1_000_000 micro-STX.
;; - Contract uses pull-payments for safety: winner/refund must call to withdraw.
;; - Contract creator has no ability to withdraw funds from the contract.
;; - State machine enforced via `status` data-var.

(use-trait trt-burn 'STX) ;; placeholder if needed - not used

;; -----------------------------
;; Constants (error codes, params)
;; -----------------------------
(define-constant ERR-ALREADY-INITIALIZED u100)
(define-constant ERR-NOT-OPEN u101)
(define-constant ERR-DEADLINE-PASSED u102)
(define-constant ERR-DEADLINE-NOT-PASSED u103)
(define-constant ERR-ALREADY-ENTERED u104)
(define-constant ERR-INSUFFICIENT-FEE u105)
(define-constant ERR-MAX-PARTICIPANTS u106)
(define-constant ERR-NOT-ENOUGH-PLAYERS u107)
(define-constant ERR-WINNER-NOT-SET u108)
(define-constant ERR-NOT-WINNER u109)
(define-constant ERR-ALREADY-CLAIMED u110)
(define-constant ERR-INVALID-STATUS u111)
(define-constant ERR-REFUNDS-NOT-ALLOWED u112)

;; Example operational parameters. Values are expressed in micro-STX where applicable.
;; Change these constants before deploying to set a different fixed configuration.
(define-constant entry-fee u10000000) ;; 10 STX = 10 * 1_000_000 micro-STX
(define-constant min-players u3)
(define-constant max-participants u100)

;; Lottery statuses (enum as uint)
(define-constant STATUS-OPEN u0)
(define-constant STATUS-READY-TO-DRAW u1)
(define-constant STATUS-COMPLETED u2)
(define-constant STATUS-REFUNDED u3)

;; -----------------------------
;; Persistent contract state
;; -----------------------------

;; Current lottery status
(define-data-var status uint STATUS-OPEN)

;; Target block height after which drawing is allowed
(define-data-var target-block-height uint u0)

;; Total participants count (also used as next-index)
(define-data-var total-participants uint u0)

;; Map: participant principal -> index (uint). Allows quick membership checks.
(define-map participant-index
  ((participant principal))
  ((index uint)))

;; Map: index -> participant principal. Allows picking a winner by index.
(define-map participant-by-index
  ((index uint))
  ((participant principal)))

;; Winner stored as optional principal. `none` until winner selected.
(define-data-var winner (optional principal) none)

;; Pull-payment maps: winnings and refunds tracked here. Only contract transfers out.
(define-map payouts
  ((recipient principal))
  ((amount uint)))

;; Track which participants have claimed refunds (participant -> bool)
(define-map refund-claimed
  ((participant principal))
  ((claimed bool)))

;; Creator principal (set at first call to `init`), optional. Creator has no withdraw rights.
(define-data-var creator (optional principal) none)

;; -----------------------------
;; Helpers
;; -----------------------------

;; Read current block height (wrapper around builtin)
(define-private (get-current-block-height)
  (ok (get-block-info? 'height)))

;; Calculate the current prize pool: total participants * entry-fee
(define-read-only (calculate-prize-pool)
  (ok (mul (var-get total-participants) entry-fee)))

;; Internal: add payout amount to `payouts` map for a recipient
(define-private (add-payout (recipient principal) (amount uint))
  (let ((existing (map-get? payouts {recipient: recipient})))
    (match existing
      existing-row
      (begin
        (map-set payouts {recipient: recipient} {amount: (+ (get amount existing-row) amount)})
        (ok true))
      (begin
        (map-set payouts {recipient: recipient} {amount: amount})
        (ok true)))))

;; Internal: check if a participant is already registered
(define-read-only (is-participant (p principal))
  (ok (is-some (map-get? participant-index {participant: p}))))

;; -----------------------------
;; Initialization (optional)
;; - Caller may set the target block height once.
;; - Also records the creator principal (for record-keeping only).
;; Note: creator cannot withdraw funds; this is only informational.
;; -----------------------------
(define-public (init (target-block uint))
  (begin
    (match (var-get creator)
      some-creator (err ERR-ALREADY-INITIALIZED)
      none
      (begin
        (var-set creator (some tx-sender))
        (var-set target-block-height target-block)
        ;; default paused false; creator is admin and cannot withdraw funds
        (var-set paused false)
        (ok true)))))

;; -----------------------------
;; Admin controls
;; -----------------------------

;; Pause the lottery (only admin/creator)
(define-public (pause)
  (begin
    (match (var-get creator)
      none (err ERR-INVALID-STATUS)
      (some admin)
      (begin
        (asserts! (is-eq admin tx-sender) (err ERR-NOT-ADMIN))
        (var-set paused true)
        (ok true)))))

;; Unpause the lottery (only admin/creator)
(define-public (unpause)
  (begin
    (match (var-get creator)
      none (err ERR-INVALID-STATUS)
      (some admin)
      (begin
        (asserts! (is-eq admin tx-sender) (err ERR-NOT-ADMIN))
        (var-set paused false)
        (ok true)))))

;; -----------------------------
;; Public: enter-lottery
;; - Transfers `entry-fee` STX from tx-sender to this contract using `stx-transfer?`.
;; - Prevents duplicate entries.
;; - Only allowed while lottery is `STATUS-OPEN` and before `target-block-height`.
;; - Uses maps to track participants and index assignment.
;; -----------------------------
(define-public (enter-lottery)
  (begin
    ;; ensure lottery is open
    (asserts! (is-eq (var-get status) STATUS-OPEN) (err ERR-NOT-OPEN))

    ;; ensure not paused by admin
    (asserts! (not (var-get paused)) (err ERR-PAUSED))

    ;; ensure target-block-height set and not passed
    (let ((target (var-get target-block-height)))
      (asserts! (> target u0) (err ERR-INVALID-STATUS))
      (let ((current (unwrap-panic (get-current-block-height))))
        (asserts! (< current target) (err ERR-DEADLINE-PASSED)))))

    ;; prevent duplicate entries
    (match (map-get? participant-index {participant: tx-sender})
      some-row (err ERR-ALREADY-ENTERED)
      none
      (begin
        ;; ensure max participants not exceeded
        (let ((count (var-get total-participants)))
          (asserts! (< count max-participants) (err ERR-MAX-PARTICIPANTS)))

        ;; transfer STX from caller to contract
        (let ((xfer (stx-transfer? entry-fee tx-sender (as-contract))))
          (match xfer
            success
            (begin
              ;; add participant -> index mapping
              (let ((idx (var-get total-participants)))
                (map-set participant-index {participant: tx-sender} {index: idx})
                (map-set participant-by-index {index: idx} {participant: tx-sender})
                (var-set total-participants (+ idx u1))

                ;; after adding, if we reached max or block passed, set READY-TO-DRAW if min satisfied
                (let ((new-count (var-get total-participants)) (target (var-get target-block-height)))
                  (match (get-current-block-height)
                    (ok curr)
                    (if (or (>= new-count min-players) (>= curr target))
                      (var-set status STATUS-READY-TO-DRAW)
                      (ok true))
                    (err ERR-INVALID-STATUS)))

                (ok true)))
            err (err ERR-INSUFFICIENT-FEE)))))))

;; -----------------------------
;; Public: draw-winner
;; - Anyone can call after `target-block-height`.
;; - Requires at least `min-players` participants.
;; - Uses block header hash and participants data to pick an index.
;; - Marks lottery as COMPLETED and schedules payout for the winner.
;; -----------------------------
(define-public (draw-winner)
  (begin
    ;; only allow when open or ready-to-draw
    (let ((st (var-get status)))
      (asserts! (or (is-eq st STATUS-OPEN) (is-eq st STATUS-READY-TO-DRAW)) (err ERR-INVALID-STATUS)))

    ;; ensure not paused by admin
    (asserts! (not (var-get paused)) (err ERR-PAUSED))

    ;; ensure deadline has passed
    (let ((target (var-get target-block-height)))
      (let ((curr-or-err (get-current-block-height)))
        (match curr-or-err
          (ok curr) (asserts! (>= curr target) (err ERR-DEADLINE-NOT-PASSED))
          err (err ERR-INVALID-STATUS)))))

    ;; ensure enough players
    (let ((count (var-get total-participants)))
      (asserts! (>= count min-players) (err ERR-NOT-ENOUGH-PLAYERS)))

    ;; compute pseudo-random index using block header hash + participants
    (match (get-block-info? 'header-hash)
      header-buffer
      (let ((count (var-get total-participants)))
        ;; Convert header-buffer to a simple uint by summing bytes modulo `count`.
        ;; This is deterministic but mixes in block header entropy.
        ;; NOTE: Clarity does not expose arbitrary big-int from buffer; we'll fold bytes.
        (let ((len (len header-buffer)))
          (let loop ((i u0) (acc u0))
            (if (>= i len)
                (let ((winner-idx (mod acc count)))
                  ;; retrieve winner principal at index
                  (match (map-get? participant-by-index {index: winner-idx})
                    some-row
                    (let ((winner-pr (get participant some-row)))
                      ;; set winner and mark completed
                      (var-set winner (some winner-pr))
                      (var-set status STATUS-COMPLETED)
                      ;; schedule payout: entire prize pool to winner (pull pattern)
                      (let ((pool (mul count entry-fee)))
                        (add-payout winner-pr pool)
                        (ok winner-pr)))
                    none (err ERR-WINNER-NOT-SET)))
                (let ((b (buffer-get header-buffer i)))
                  (recur (+ i u1) (+ acc (u8-to-uint b))))))))
      none (err ERR-INVALID-STATUS)))

;; -----------------------------
;; Public: claim-prize
;; - Winner calls to withdraw their entire prize balance.
;; - Uses pull-payment: contract transfers STX to winner on request.
;; - Only callable after lottery completed and if caller has payout balance.
;; -----------------------------
(define-public (claim-prize)
  (begin
    (asserts! (is-eq (var-get status) STATUS-COMPLETED) (err ERR-INVALID-STATUS))
    ;; check that caller is the recorded winner
    (match (var-get winner)
      none (err ERR-WINNER-NOT-SET)
      (some winner-pr)
      (begin
        (asserts! (is-eq winner-pr tx-sender) (err ERR-NOT-WINNER))
        ;; check payout amount
        (match (map-get? payouts {recipient: tx-sender})
          none (err ERR-WINNER-NOT-SET)
          payout-row
          (let ((amt (get amount payout-row)))
            ;; prevent double-claim by deleting mapping before transfer
            (map-delete payouts {recipient: tx-sender})
            (let ((res (stx-transfer? amt (as-contract) tx-sender)))
              (match res
                success (ok amt)
                err (err ERR-INVALID-STATUS))))))))

;; -----------------------------
;; Public: refund
;; - Called by participant to claim their entry back when lottery failed to meet min players
;; - Only allowed if lottery status is REFUNDED or if deadline passed and min not met
;; - Each participant can only claim once.
;; -----------------------------
(define-public (refund)
  (begin
    ;; ensure we are in REFUNDED status or conditions allow refunds
    (let ((st (var-get status)))
      (if (is-eq st STATUS-REFUNDED)
          (ok true)
          (begin
            ;; compute conditions for refunds: deadline passed and not enough players
            (let ((target (var-get target-block-height)))
              (let ((curr-or-err (get-current-block-height)))
                (match curr-or-err
                  (ok curr)
                  (begin
                    (asserts! (>= curr target) (err ERR-DEADLINE-NOT-PASSED))
                    (asserts! (< (var-get total-participants) min-players) (err ERR-REFUNDS-NOT-ALLOWED))
                    ;; set status to REFUNDED if not already
                    (var-set status STATUS-REFUNDED)
                    (ok true))
                  err (err ERR-INVALID-STATUS)))))))

    ;; ensure caller is participant
    (match (map-get? participant-index {participant: tx-sender})
      none (err ERR-NOT-ENOUGH-PLAYERS)
      some-row
      (begin
        ;; ensure not already claimed
        (match (map-get? refund-claimed {participant: tx-sender})
          some-claim (match (get claimed some-claim) true (err ERR-ALREADY-CLAIMED) false (err ERR-ALREADY-CLAIMED))
          none
          (let ((idx (get index some-row)))
            ;; mark claimed
            (map-set refund-claimed {participant: tx-sender} {claimed: true})
            ;; schedule transfer via payouts map (pull pattern)
            (add-payout tx-sender entry-fee)
            ;; and attempt immediate transfer from contract to caller
            (match (map-get? payouts {recipient: tx-sender})
              some-pay
              (let ((amt (get amount some-pay)))
                (map-delete payouts {recipient: tx-sender})
                (let ((x (stx-transfer? amt (as-contract) tx-sender)))
                  (match x
                    success (ok amt)
                    err (err ERR-INVALID-STATUS))))
              none (err ERR-INVALID-STATUS)))))))))

;; -----------------------------
;; Read-only getters
;; -----------------------------

(define-read-only (get-lottery-info)
  (ok {
    status: (var-get status),
    target-block-height: (var-get target-block-height),
    total-participants: (var-get total-participants),
    prize-pool: (mul (var-get total-participants) entry-fee),
    entry-fee: entry-fee,
    min-players: min-players,
    max-participants: max-participants,
    winner: (var-get winner),
    creator: (var-get creator)
  }))

(define-read-only (get-participant (p principal))
  (ok (map-get? participant-index {participant: p})))

(define-read-only (get-winner)
  (ok (var-get winner)))

(define-read-only (is-refund-claimed (p principal))
  (ok (match (map-get? refund-claimed {participant: p}) some (get claimed some) none false)))

;; End of contract
